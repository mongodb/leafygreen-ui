# Code Generation Instructions

These guidelines are intended to standardize how code is generated for this codebase. They are designed to be both human- and AI-readable to ensure consistency and compatibility with tools like GitHub Copilot.

## TypeScript Guidelines

- Use TypeScript for all new code
- Follow functional programming principles where possible
- Use interfaces for data structures and type definitions where possible
- Prefer immutable data (const, readonly)
- Avoid enums; use `as const` objects with derived types to allow value-based usage and improve compatibility
- Place types/interfaces at the top of the file above functional code; if multiple types are declared, use a separate `*.types.ts` file for clarity and separation
- Prefer typing `children` prop as `ReactNode` where possible

## JavaScript Guidelines

### Functions

- Prefer ternary expressions for simple conditionals instead of `if`/`else` blocks
- Prefer `if`/`else` blocks for complex branching instead of nested or chained ternaries
- Include a JSDoc comment for every new exported function, explaining its purpose, assumptions, inputs, and outputs
- Define functions at the highest reasonable scope and pass all necessary arguments to keep them pure and testable

### Variable Naming

- Use UPPERCASE for static constants; refactor them to a shared file if reused across multiple files
- Use camelCase for most variables and functions
- Use PascalCase for components, classes, and React elements
- Prefix boolean variables with "to be" verbs like `isX`, `hasY`, `canZ`, `shouldDoX`, etc. to clarify intent
- Use `data-testid` or `data-lgid` only on root-level native HTML elements (not React components)
- Follow a BEM-ish format for test IDs, using `-` to separate blocks and `_` to separate words

### Variable Placement

- Move static constants to the top of the file or a separate module
- Declare `let`/`const` variables at the beginning of their scope to improve readability and reduce hoisting confusion
- Prefer `const` over `let` whenever possible

### Styling

- Define Emotion styles in a separate `*.styles.ts` file then import and reference via `className` prop
- Postfix Emotion `css` variables with `*Styles` or `*Style`
- Postfix Emotion variables with values generated by `createUniqueClassName()` with `*ClassName`
- Avoid using CSS variables (`var(--token)`) in components; prefer scoped class selectors with `createUniqueClassName` and JS constants

### React

- Refactor multi-line event handlers into their own named functions
- Prefix all event handler functions with `handle*` (e.g. `handleClick` or `handleSubmit`)
- Prefer `React.Fragment` (`<>...</>`) over `div` when no styling or semantics are needed
- Avoid `React.cloneElement`; prefer render props, context, or custom hooks to pass data to children
- Use the spred operator (`{ ...originalObject }`) to avoid directly mutating objects or arrays
- Forward refs using `React.forwardRef` when exposing access to a DOM element.
- Use utility functions when full component state/logic isn't needed

### LeafyGreen Usage

- Use the `useDarkMode()` hook to read the `darkMode` value from `LeafyGreenProvider`, and allow local overrides when needed
- Wrap children in a `LeafyGreenProvider` instead of passing the `darkMode` prop to each child individually
- Use `state="error"` to visually indicate input errors and enable error messaging
- Set the `errorMessage` prop to show a descriptive error next to the input
  If `state="error"` and `errorMessage` is not defined, use `aria-describedby`
