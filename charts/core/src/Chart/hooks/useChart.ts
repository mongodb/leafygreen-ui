import { RefCallback, useCallback, useEffect, useRef, useState } from 'react';

import { useEchart } from '../../Echart';
import { EChartEvents } from '../../Echart';
import { getDefaultChartOptions } from '../config';

import type { ChartHookProps, ChartInstance } from './useChart.types';

// TODO(LG-4803): Fix linting issues
/* eslint-disable react-hooks/exhaustive-deps */

export function useChart({
  onChartReady = () => {},
  zoomSelect,
  onZoomSelect,
  groupId,
  theme,
  state,
}: ChartHookProps): ChartInstance {
  const initialOptions = getDefaultChartOptions(theme);

  /**
   * It is necessary for `useEchart` to know when the container exists
   * in order to instantiate the chart. Since this happens only on first render,
   * we use a container element stored in state and a ref callback so that the
   * element only gets populated after render.
   */
  const [container, setContainer] = useState<HTMLDivElement | null>(null);
  const chartRef: RefCallback<HTMLDivElement> = useCallback(node => {
    setContainer(node);
  }, []);
  const echart = useEchart({
    container,
    initialOptions,
    theme,
  });

  useEffect(() => {
    if (echart.ready) {
      onChartReady();
    }
  }, [echart.ready]);

  useEffect(() => {
    if (echart.ready) {
      if (groupId) {
        echart.addToGroup(groupId);
      }

      return () => {
        echart.removeFromGroup();
      };
    }
  }, [echart.ready, groupId]);

  // SETUP AND ENABLE ZOOM
  useEffect(() => {
    if (echart.ready) {
      echart.setupZoomSelect({
        xAxis: zoomSelect?.xAxis,
        yAxis: zoomSelect?.yAxis,
      });

      if (zoomSelect?.xAxis || zoomSelect?.yAxis) {
        function enableZoomOnRender() {
          echart.enableZoom();
          /**
           * Enabling zoom triggers a render, so once we enable it, we want to
           * remove the handler or else there will be an infinite loop of
           * render -> enable -> render -> etc.
           */
          echart?.off('rendered', enableZoomOnRender);
        }

        echart?.on('rendered', enableZoomOnRender);
      }
    }
  }, [echart.ready, zoomSelect]);

  useEffect(() => {
    if (echart.ready && onZoomSelect) {
      echart.on(EChartEvents.ZoomSelect, zoomEventResponse => {
        onZoomSelect(zoomEventResponse);
      });
    }
  }, [echart.ready, onZoomSelect]);

  function hideTooltip() {
    echart.hideTooltip();
  }

  // We want to hide the tooltip when it's hovered over any `EventMarkerPoint`
  useEffect(() => {
    if (echart.ready) {
      echart.on('mouseover', e => {
        if (e.componentType === 'markPoint') {
          hideTooltip();
          echart.on('mousemove', hideTooltip);
        }
      });

      // Stop hiding once the mouse leaves the `EventMarkerPoint`
      echart.on('mouseout', e => {
        if (e.componentType === 'markPoint') {
          echart.off('mousemove', hideTooltip);
        }
      });
    }
  }, [echart, echart.ready]);

  const initialRenderRef = useRef(true);

  const handleResize = useCallback(() => {
    if (echart.ready) {
      // Skip the first resize event, as it's triggered by the initial render
      if (initialRenderRef.current) {
        initialRenderRef.current = false;
        return;
      }

      if (zoomSelect?.xAxis || zoomSelect?.yAxis) {
        /**
         * If the chart has been resized, the chart appears to reset zoom, which
         * disables it. We need to re-enable it after the resize however, doing so
         * immediately doesn't work. To work around this, we listen for the `finished`
         * event, which is triggered after the chart has been rendered, and then
         * execute the re-enable zoom logic after all tasks on the queue have been
         * processed.
         *
         * TODO(LG-4818): Investigate why this is necessary
         */
        function reEnableZoom() {
          function reEnableZoomCallback() {
            echart.enableZoom();
            echart.off('finished', reEnableZoom);
          }
          setTimeout(reEnableZoomCallback, 0);
        }

        echart.on('finished', reEnableZoom);
      }

      echart.resize();
    }
  }, [echart.ready, initialRenderRef, zoomSelect]);

  useEffect(() => {
    if (echart.ready && container) {
      const resizeObserver = new ResizeObserver(handleResize);
      resizeObserver.observe(container);

      return () => {
        resizeObserver.disconnect();
      };
    }
  }, [echart.ready, container, handleResize]);

  return {
    ...echart,
    ref: chartRef,
    state,
  };
}
